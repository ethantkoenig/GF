# Operations for a modified form of regular expressions:
#  - any string (without parentheses and square brackets) is a regex
#  - if S1, .. , Sn are strings, (S1|..|Sn) is a regex (alternation)
#  - if R1 and R2 are regexs R1R2 is a regex (concatenation)
#  - if R is a regex, [R] is a regex (optionality)




# Returns : int * int - (start, end) indices of first (..) or [..] group
#                       (-1, 0) if none exist, raise exception if no closing
def findOpen(regex):
  index = 0
  while(index < len(regex) and regex[index] not in ["(", "["]):
    index += 1
  if(index == len(regex)):
    return (-1, 0)
  openSymbol = regex[index]
  closeSymbol = ")" if regex[index] == "(" else "]"
  startIndex = index
  index += 1
  nesting = 1
  while (index < len(regex) and nesting > 0):
    if (regex[index] == openSymbol):
      nesting += 1
    elif (regex[index] == closeSymbol):
      nesting -= 1
    index += 1
  if(nesting == 0):
    return (startIndex, index)
  raise ValueError ("not well nested: %s" % regex)



# Returns : str list -  strings generated by regex
#
# regex : str - regex as specified above
def generateAll(regex):
  (openIndex, closeIndex) = findOpen(regex)
  if(openIndex == -1):
    return [regex]
  preface = regex[:openIndex]
  if(regex[openIndex] == "("):
    parenContents = regex[openIndex+1:closeIndex-1]
    alternatives = union(*parenContents.split("|"))
    return [preface + alternative + postface
            for alternative in alternatives
            for postface in generateAll(regex[closeIndex:])]
  elif(regex[openIndex] == "["):
    options = union("", regex[openIndex+1:closeIndex-1])
    return [preface + option + postface
            for option in options
            for postface in generateAll(regex[closeIndex:])]
  else:
    raise AssertionError ("internal error")


# Returns : str list - union of strings generated by given regexs
#
# regexs : str - regexs as specified above
def union(*regexs):
  return list(set(string for regex in regexs
                         for string in generateAll(regex)))
